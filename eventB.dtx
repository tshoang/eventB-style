% \iffalse meta-comment
% 
% eventB.ins
% 
% Copyright (C) 2012 by Thai Son Hoang <htson at inf dot ethz dot ch>
% --------------------------------------------------------------------
% 
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in:
% 
%      http://www.latex-project.org/lppl.txt
% 
% and version 1.3 or later is part of all distributions of LaTeX 
% version 2003/12/01 or later.
% 
% This work has the LPPL maintenance status "author-maintained".
% 
% This work consists of the files eventB.dtx, eventB.ins,
% the derived file eventB.sty, the generated documentation
% eventB.pdf, and some sample documents.
% 
% \fi
% 
% \iffalse
%<eventB>%%%%% BEGIN Identification part %%%%%
%<eventB>\NeedsTeXFormat{LaTeX2e}\relax
%<eventB>\ProvidesPackage{eventB}
%<eventB>    [2012/02/21 v1.1.1 Package for typesetting Event-B models] 
%<eventB>%%%%% END Identification part %%%%%
% 
%<*driver> 
\documentclass[a4paper]{ltxdoc}
\usepackage{eventB}
\EnableCrossrefs
% ^^A Enable either \CodelineIndex or \PageIndex
\CodelineIndex
% ^^A\PageIndex
\RecordChanges

\begin{document}
\DocInput{eventB.dtx}
\end{document}
%</driver> 
% \fi
% 
% \CheckSum{0}
% 
% \CharacterTable
% {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
% Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
% Digits        \0\1\2\3\4\5\6\7\8\9
% Exclamation   \!     Double quote  \"     Hash (number) \#
% Dollar        \$     Percent       \%     Ampersand     \&
% Acute accent  \'     Left paren    \(     Right paren   \)
% Asterisk      \*     Plus          \+     Comma         \,
% Minus         \-     Point         \.     Solidus       \/
% Colon         \:     Semicolon     \;     Less than     \<
% Equals        \=     Greater than  \>     Question mark \?
% Commercial at \@     Left bracket  \[     Backslash     \\
% Right bracket \]     Circumflex    \^     Underscore    \_
% Grave accent  \`     Left brace    \{     Vertical bar  \|
% Right brace   \}     Tilde         \~}
% 
% 
% \changes{v1.0}{2012/07/03}{Initial version}
% \changes{v1.0.1}{2013/02/19}{Ensure that the keywords, labels are in math-mode}
% \changes{v1.1}{2013/02/19}{Re-implement how options are defined,
% added options 'box'}
% \changes{v1.1.1}{2013/02/23}{Updated documentation}
%
% \GetFileInfo{eventB.sty}
%
% \title{The \textsf{eventB} package\thanks{This document
% corresponds to \textsf{eventB}~\fileversion, dated~\filedate.}}
% \author{Thai Son Hoang \\ ETH-Zurich \\ \texttt{<htson at inf dot
% ethz dot ch>}}
% \date{\today}
% 
% \maketitle
% 
% ^^A %%%%% Abstract %%%%%
% \begin{abstract}
%   This class provides a template for typesetting Event-B models.  It was
%   developed at the Swiss Federal Institute of Technology Zurich
%   (ETH-Zurich).
% \end{abstract}
% 
% ^^A %%%%% Table of contents %%%%%
% \tableofcontents
% 
% ^^A %%%%% Introduction %%%%%
% \section{Introduction}
% 
% This package was developed in order to ease the typesetting of
% Event-B models in \LaTeX{}.
% 
% ^^A %%%%% Usage %%%%%%
% \section{Usage}
% See |sample-eventB.tex| for an example of how to use the package.
% 
% \subsection{Package Options}
% \label{sec:package-options}
% The package offers the following options:
% \begin{itemize}
% \item |nobox|: to disable to bounding boxes for the \eventB
% modelling elements,
% \item |small|, |compact|, |tiny|: options for font size,
% \item |colour| (or |color|): to colour several modelling elements.
% \end{itemize}

% \StopEventually{
% \PrintIndex
% \PrintChanges
% }
%
% ^^A %%%%% Implementation %%%%%
% \section{Implementation}
%
% \subsection{Package Loading}
% \label{sec:package-loading}
% We begin by loading the required package |xspace| and |xcolor|.

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>%%%%% BEGIN Package loading %%%%%
% \fi^^A END Produce comments only in the resulting class file

%    \begin{macrocode}
\RequirePackage{xspace}
\RequirePackage{xcolor}
\RequirePackage{ifthen}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>%%%%% END Package loading %%%%%
% \fi^^A END Produce comments only in the resulting class file

% \subsection{Declaration of Options for the Package}
% \label{sec:options}

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>%%%%% BEGIN Declaration of options %%%%%
% \fi^^A END Produce comments only in the resulting class file

% In this part various options for the package are defined.

% \paragraph{Option for rounding boxes}
% By default, \eventB modelling elements, e.g., invariants, events,
% etc., are displayed in a rounding box.  This option enables them to
% be displayed without the rounding box.

%    \begin{macrocode}
\newlength{\B@oldfboxsep}
\newcommand{\event}[7][]{
  \setlength{\B@oldfboxsep}{\fboxsep}
  \setlength{\fboxsep}{2ex}
  \fbox{
    \ensuremath{
      \B@event[#1]{#2}{#3}{#4}{#5}{#6}{#7}
    }
  }
  \setlength{\fboxsep}{\B@oldfboxsep}
}

\newcommand{\B@declaration}[2]{
  \setlength{\B@oldfboxsep}{\fboxsep}
  \setlength{\fboxsep}{2ex}
  \fbox{
    \ensuremath{
      \B@declarationbase{#1}{#2}
    }
  }
  \setlength{\fboxsep}{\B@oldfboxsep}
}

\newcommand{\B@section}[3][]{
  \setlength{\B@oldfboxsep}{\fboxsep}
  \setlength{\fboxsep}{2ex}
  \fbox{
    \ensuremath{
      \B@sectionbase[#1]{#2}{#3}
    }
  }
  \setlength{\fboxsep}{\B@oldfboxsep}
}

\DeclareOption{nobox}{
  \renewcommand{\event}[7][]{
    \B@event[#1]{#2}{#3}{#4}{#5}{#6}{#7}
  }
  
  \renewcommand{\B@declaration}[2]{
    \B@declarationbase{#1}{#2}
  }
  
  \renewcommand{\B@section}[3][]{
    \B@sectionbase[#1]{#2}{#3}
  }
}

%    \end{macrocode}

% \paragraph{Options for font size and spacing}
% We define the default values for font size and some spacing
% commands, and how the are redefined according to options |small|,
% |compact|, and |tiny|. In particular, option |compact| and |tiny|
% implies option |nobox|.

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Options for font size and spacing %%%%%
% \fi^^A END Produce comments only in the resulting class file

%    \begin{macrocode}
\newcommand{\B@fontsize}{\normalsize} % The font size used in Bcode environment
\newcommand{\Bvspace}[1][2ex]{\\[#1]} % Vertical space
\newcommand{\Bhspace}[1][2em]{\hspace{#1}} % Horizontal space
\newcommand{\B@tab}{\quad} % A small separation space

\DeclareOption{small}{
  \renewcommand{\B@fontsize}{\small}
  \renewcommand{\Bvspace}[1][1ex]{\\[#1]}
  \renewcommand{\Bhspace}[1][1em]{\hspace{#1}}
  \renewcommand{\B@tab}{\ }
}
\DeclareOption{compact}{
  \renewcommand{\B@fontsize}{\footnotesize}
  \renewcommand{\Bvspace}[1][0ex]{\\[#1]}
  \renewcommand{\Bhspace}[1][0.5em]{\hspace{#1}}
  \renewcommand{\B@tab}{\ }
  \ExecuteOptions{nobox}
}
\DeclareOption{tiny}{
  \renewcommand{\B@fontsize}{\scriptsize}
  \renewcommand{\Bvspace}[1][-0.5ex]{\\[#1]}
  \renewcommand{\Bhspace}[1][0.5em]{\hspace{#1}}
  \renewcommand{\B@tab}{\ }
  \ExecuteOptions{nobox}
}

%    \end{macrocode}

% \paragraph{Options for colouring}
% Keywords, labels and identifiers in Event-B can be coloured. We
% define several commands and redefine them accordingly for
% colouring.  When |colour| (or |color|) option is enabled, one can
% customise the colours for Event-B keywords, labels or identifier or
% proof obligation labels.

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Options for colouring %%%%%
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\B@keyword}[1]{\ensuremath{\B@keywordbase{#1}}\xspace}
\newcommand{\Bidentifier}[1]{\ensuremath{\B@identifier{#1}}\xspace}
\newcommand{\Blabel}[2][]{\ensuremath{\B@label[#1]{#2}}\xspace}
\newcommand{\Bpo}[1]{\ensuremath{\B@po{#1}}\xspace}
\DeclareOption{colour}{
  \newcommand{\setBKeywordColour}[1]{\colorlet{B@keywordcolor}{#1}}
  \setBKeywordColour{blue}
  \newcommand{\setBIdentifierColour}[1]{\colorlet{B@identifiercolor}{#1}}
  \setBIdentifierColour{blue!50!red}  
  \newcommand{\setBLabelColour}[1]{\colorlet{B@labelcolor}{#1}}
  \setBLabelColour{green!50!black}
  \newcommand{\setBPOColour}[1]{\colorlet{B@pocolor}{#1}}
  \setBPOColour{red}
  \renewcommand{\B@keyword}[1]{
    \ensuremath{\textcolor{B@keywordcolor}{\B@keywordbase{#1}}}\xspace
  }
  \renewcommand{\Bidentifier}[1]{
    \ensuremath{\textcolor{B@identifiercolor}{\B@identifier{#1}}}\xspace
  }
  \renewcommand{\Blabel}[2][]{
    \ensuremath{\textcolor{B@labelcolor}{\B@label[#1]{#2}}}\xspace
  }
  \renewcommand{\Bpo}[1]{
    \ensuremath{\textcolor{B@pocolor}{\B@po{#1}}}\xspace
  }
}
\DeclareOption{color}{
  \ExecuteOptions{colour}
}

%    \end{macrocode}
%
% After declaration of options, we execute them accordingly. 
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>%%%%% BEGIN Execution of options %%%%%
%<eventB>
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\ProcessOptions
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>%%%%% END Execution of options %%%%%
%<eventB>
% \fi^^A END Produce comments only in the resulting class file

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>%%%%% END Declaration of options %%%%%
%<eventB>
% \fi^^A END Produce comments only in the resulting class file

%

% \subsection{Commands for Pretty-Print Event-B Models}
% \label{sec:comm-pretty-print}

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>%%%%% BEGIN Commands for Pretty-Print Event-B Models %%%%%
% \fi^^A END Produce comments only in the resulting class file

% We start with the definition of the |\eventB| macro.
%    \begin{macrocode}
\newcommand{\eventB}{Event-B\xspace}
%    \end{macrocode}

% The |Bcode| environment for displaying \eventB models.  The
% environment has an optional argument for specifying the font size.
% By default, it is the same as the |\B@fontsize| controlled by the
% package option.   
% 
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Bcode environment %
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newenvironment{Bcode}[1][\B@fontsize]{\begin{center}#1}{\end{center}}
%    \end{macrocode}

% \paragraph{Declarations and Collections}
% \eventB modelling elements are organised into declarations (e.g.,
% variables, constants, etc.) or collections (e.g., invariants,
% axioms).  For each declaration, the input is a comma-separated list
% of elements.  For each collection, the input is a
% newly(|\\|)-separated list of elements.
%
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print carrier sets
%<eventB>% Arguments:
%<eventB>% 1. (Comma-separated) list of carrier sets.
%<eventB>%
%<eventB>% Usage: \carriersets{S, T}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\carriersets}[1]{
  \B@declaration{sets}{#1}
}
%    \end{macrocode}

% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print constants
%<eventB>% Arguments:
%<eventB>% 1. (Comma-separated) list of constants.
%<eventB>%
%<eventB>% Usage: \constants{m, n}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\constants}[1]{
  \B@declaration{constants}{#1}
}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print axioms
%<eventB>% Arguments:
%<eventB>% 1. (Newline(\\)-separated) list of axioms.
%<eventB>%
%<eventB>% Usage: \axioms{\Baxm{axm0\_1}: & x \in \nat \\
%<eventB>%                \Baxm{axm0\_2}: & y \in \nat \\[2ex]}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\axioms}[2][]{
  \B@section[#1]{axioms}{#2}
}
%    \end{macrocode}
%
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print variables
%<eventB>% Arguments:
%<eventB>% 1. (Comma-separated) list of variables.
%<eventB>%
%<eventB>% Usage: \variables{x, y}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\variables}[1]{
  \B@declaration{variables}{#1}
}
%    \end{macrocode}
%
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print invariants
%<eventB>% Arguments:
%<eventB>% 1. (Newline(\\)-separated) list of invariants.
%<eventB>%
%<eventB>% Usage: \invariants{\Binv{inv0\_1:} & x \in \nat \\
%<eventB>%                    \Binv{inv0\_2:} & y \in \nat \\[2ex]}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\invariants}[2][]{
  \B@section[#1]{invariants}{#2}
}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty print variant
%<eventB>% Arguments:
%<eventB>% 1. The variant
%<eventB>%
%<eventB>% Usage: \variant{V}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\variant}[1]{
  \B@declaration{variant}{#1}
}
%    \end{macrocode}
%
% \paragraph{Event-B keywords}
% We define the keywords for pretty-print \eventB models.
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Event-B keywords for pretty-printing events %
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\Bany}{\B@keyword{any}}
\newcommand{\Bbegin}{\B@keyword{begin}}
\newcommand{\Bend}{\B@keyword{end}}
\newcommand{\Brefines}{\B@keyword{refines}}
\newcommand{\Bstatus}{\B@keyword{status}}
\newcommand{\Bthen}{\B@keyword{then}}
\newcommand{\Bwhen}{\B@keyword{when}}
\newcommand{\Bwhere}{\B@keyword{where}}
\newcommand{\Bwith}{\B@keyword{with}}
%    \end{macrocode}
%
% \paragraph{Event-B modelling elements}
% We define several macros for pretty-print \eventB modelling elements.
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Pretty-print Event-B modelling elements %
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\Bctx}[1]{\ensuremath{\mathbf{#1}}\xspace}
\newcommand{\Bset}[1]{\Bidentifier{#1}}
\newcommand{\Bcst}[1]{\Bidentifier{#1}}
\newcommand{\Baxm}[1]{\Blabel{#1}}
\newcommand{\Bthm}[1]{\Blabel[thm]{#1}}

\newcommand{\Bmch}[1]{\ensuremath{\mathbf{#1}}\xspace}
\newcommand{\Bvrb}[1]{\Bidentifier{#1}}
\newcommand{\Binv}[1]{\Blabel{#1}}
\newcommand{\Bevt}[1]{\Blabel{#1}}
\newcommand{\Bpar}[1]{\Bidentifier{#1}}
\newcommand{\Bact}[1]{\Blabel{#1}}
\newcommand{\Bgrd}[1]{\Blabel{#1}}
\newcommand{\Bbap}[1]{\hbox{\sl\bfseries #1}}
%    \end{macrocode}
%
%
% \paragraph{Meta-macros for creating macros for modelling elements}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>%%%%% BEGIN Creating Event-B modelling elements macros %%%%%
% \fi^^A END Produce comments only in the resulting class file
% We define meta-marcos to create macros for different modelling
% elements.
%
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new B macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string, (OPTIONAL) if empty then the expanded string will be used.
%<eventB>% 2. The expanded string
%<eventB>% 3. The mark-up macros, e.g. \Bvrb
%<eventB>% Usage:
%<eventB>% - \B@newmacro[aaa]{a\_a\_a}{\Bvrb} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bvrb{a\_a\_a}
%<eventB>% - \B@newmacro{aaa}{\Bvrb} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bvrb{aaa}
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\B@newmacro}[3][]{
  \ifthenelse{\equal{#1}{}}{
    \expandafter\def\csname #2\endcsname{#3{#2}}
  }{
    \expandafter\def\csname #1\endcsname{#3{#2}}
  }
}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new context macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBctx[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bctx{a\_a\_a}.
%<eventB>% - \newBctx{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bctx{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBctx}[2][]{\B@newmacro[#1]{#2}{\Bctx}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new carrier set macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBset[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bset{a\_a\_a}.
%<eventB>% - \newBset{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bset{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBset}[2][]{\B@newmacro[#1]{#2}{\Bset}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new constant macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBcst[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bcst{a\_a\_a}.
%<eventB>% - \newBcst{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bcst{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBcst}[2][]{\B@newmacro[#1]{#2}{\Bcst}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new axiom macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBaxm[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Baxm{a\_a\_a}.
%<eventB>% - \newBaxm{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Baxm{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBaxm}[2][]{\B@newmacro[#1]{#2}{\Baxm}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new theorem macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBthm[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bthm{a\_a\_a}.
%<eventB>% - \newBthm{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bthm{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBthm}[2][]{\B@newmacro[#1]{#2}{\Bthm}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new machine macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBmch[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bmch{a\_a\_a}.
%<eventB>% - \newBmch{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bmch{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBmch}[2][]{\B@newmacro[#1]{#2}{\Bmch}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new variable macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBvrb[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bvrb{a\_a\_a}.
%<eventB>% - \newBvrb{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bvrb{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBvrb}[2][]{\B@newmacro[#1]{#2}{\Bvrb}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new invariant macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBinv[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Binv{a\_a\_a}.
%<eventB>% - \newBinv{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Binv{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBinv}[2][]{\B@newmacro[#1]{#2}{\Binv}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new event macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBevt[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bevt{a\_a\_a}.
%<eventB>% - \newBevt{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bevt{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBevt}[2][]{\B@newmacro[#1]{#2}{\Bevt}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new parameter macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBpar[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bpar{a\_a\_a}.
%<eventB>% - \newBpar{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bpar{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBpar}[2][]{\B@newmacro[#1]{#2}{\Bpar}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new guard macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBgrd[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bgrd{a\_a\_a}.
%<eventB>% - \newBgrd{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bgrd{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBgrd}[2][]{\B@newmacro[#1]{#2}{\Bgrd}}
%    \end{macrocode}
% \iffalse ^^A BEGIN Produce comments only in the resulting class file
%<eventB>
%<eventB>% Create a new action macro
%<eventB>% Arguments:
%<eventB>% 1. The macro string (OPTIONAL)
%<eventB>% 2. The expanded string
%<eventB>% Usage:
%<eventB>% - \newBact[aaa]{a\_a\_a} will create a new macro \aaa
%<eventB>% which will be expanded to be \Bact{a\_a\_a}.
%<eventB>% - \newBact{aaa} will create a new macro \aaa which will be
%<eventB>% expanded to be \Bact{aaa}.
% \fi^^A END Produce comments only in the resulting class file
%    \begin{macrocode}
\newcommand{\newBact}[2][]{\B@newmacro[#1]{#2}{\Bact}}
%    \end{macrocode}
%
%
%
%    \begin{macrocode}

%%%%% Theorem Proof Obligation
%%%%% Print the theorem proof obligation, given the theorem label.
%%%%% Arguments:
%%%%% 1. Theorem label
%%%%%
%%%%% Usage:
%%%%% - \thmpo{thm} will produce "thm/THM"
\newcommand{\thmpo}[1]{\Bthm{#1}/\Bpo{THM}}

%    \end{macrocode}
%
%    \begin{macrocode}
%%%%% Axiom Well-definedness Proof Obligation
%%%%% Print the axiom well-definedness proof obligation, given the
%%%%% axiom label.
%%%%% Arguments:
%%%%% 1. Axiom label
%%%%%
%%%%% Usage:
%%%%% - \axmwdpo{axm} will produce "axm/WD"
\newcommand{\axmwdpo}[1]{\Baxm{#1}/\Bpo{WD}}

%    \end{macrocode}
%
%    \begin{macrocode}
%%%%% Invariant Proof Obligation
%%%%% Print the invariant proof obligation, given the event name and
%%%%% invariant label
%%%%% Arguments:
%%%%% 1. Event name
%%%%% 2. Invariant label
%%%%%
%%%%% Usage:
%%%%% - \invpo{evt}{inv} will produce "evt/inv/INV"
\newcommand{\invpo}[2]{\Bevt{#1}/\Binv{#2}/\Bpo{INV}}

%    \end{macrocode}
%
%
%    \begin{macrocode}
%%%%% Theorem (in guard) Proof Obligation
%%%%% Print the simulation proof obligation, given the event name and
%%%%% the theorem (in guard) label.
%%%%% Arguments:
%%%%% 1. Event name
%%%%% 2. Theorem (in guard) label
%%%%%
%%%%% Usage:
%%%%% - \grdthmpo{evt}{thm} will produce "evt/thm/THM"
\newcommand{\grdthmpo}[2]{\Bevt{#1}/\Bthm{#2}/\Bpo{THM}}

%    \end{macrocode}
%
%
%    \begin{macrocode}
%%%%% Feasibility Proof Obligation
%%%%% Print the feasibility proof obligation, given the event name and
%%%%% the action label
%%%%% Arguments:
%%%%% 1. Event name
%%%%% 2. Action label
%%%%%
%%%%% Usage:
%%%%% - \fispo{evt}{act} will produce "evt/act/FIS"
\newcommand{\fispo}[2]{\Bevt{#1}/\Bact{#2}/\Bpo{FIS}}

%    \end{macrocode}
%

%    \begin{macrocode}
%%%%% Variant finiteness Proof Obligation
%%%%% Print the Variant finiteness proof obligation
%%%%% Arguments: No arguments
%%%%%
%%%%% Usage:
%%%%% - \finpo will produce "FIN"
\newcommand{\finpo}{\Bpo{FIN}}

%    \end{macrocode}
%
%
%
%    \begin{macrocode}
%%%%% Variant Proof Obligation
%%%%% Print the guard strengthen proof obligation, given the event name
%%%%% Arguments:
%%%%% 1. Event name
%%%%%
%%%%% Usage:
%%%%% - \grdpo{evt} will produce "evt/VAR"
\newcommand{\varpo}[1]{\Bevt{#1}/\Bpo{VAR}}

%    \end{macrocode}
%
%
%
%    \begin{macrocode}
%%%%% Simulation Proof Obligation
%%%%% Print the simulation proof obligation, given the event name and
%%%%% the action label.
%%%%% Arguments:
%%%%% 1. Event name
%%%%% 2. Action label
%%%%%
%%%%% Usage:
%%%%% - \simpo{evt}{act} will produce "evt/act/SIM"
\newcommand{\simpo}[2]{\Bevt{#1}/\Bact{#2}/\Bpo{SIM}}

%    \end{macrocode}
%
%    \begin{macrocode}
%%%%% Guard Strengthen Proof Obligation
%%%%% Print the guard strengthen proof obligation, given the event
%%%%% name and the guard label
%%%%% Arguments:
%%%%% 1. (Abstract) Event name
%%%%% 2. (Abstract) Guard label
%%%%%
%%%%% Usage:
%%%%% - \grdpo{evt}{grd} will produce "evt/grd/GRD"
\newcommand{\grdpo}[2]{\Bevt{#1}/\Bgrd{#2}/\Bpo{GRD}}

%    \end{macrocode}
%
%
%
%    \begin{macrocode}
%%%%% Variant Natural Number Proof Obligation
%%%%% Print the Variant Natural Number proof obligation, given the event name
%%%%% Arguments:
%%%%% 1. Event name
%%%%%
%%%%% Usage:
%%%%% - \natpo{evt} will produce "evt/NAT"
\newcommand{\natpo}[1]{\Bevt{#1}/\Bpo{NAT}}

%    \end{macrocode}


%    \begin{macrocode}
\newcommand{\B@keywordbase}[1]{\mathbf{#1}}
\newcommand{\B@identifier}[1]{\mathit{#1}}
\newcommand{\B@label}[2][]{
  \def\is@thm{#1}
  \ifx\is@thm\@empty
  \mathsf{#2}
  \else
  \mathit{#2}
  \fi
}



\newcommand{\eventinline}[7][]{
  \setlength{\B@oldfboxsep}{\fboxsep}
  \setlength{\fboxsep}{2ex}
  \fbox{
    \ensuremath{
      \B@eventinline[#1]{#2}{#3}{#4}{#5}{#6}{#7}
    }
  }
  \setlength{\fboxsep}{\B@oldfboxsep}
}


\newcommand{\B@declarationbase}[2]{
  \begin{array}{l@{\B@tab}l}
    \B@keyword{#1:} &  #2 
  \end{array}
}

\newcommand{\B@sectionbase}[3][]{
  \def\no@title{#1}
  \ifx\no@title\@empty
  \begin{array}{l}
    \B@keyword{#2:} \\
    \begin{array}{l@{\B@tab}l}
      #3
    \end{array}
  \end{array}
  \else
  \begin{array}{l@{\B@tab}l}
    #3
  \end{array}
  \fi
}

\newcommand{\B@po}[1]{\ensuremath{\mathsf{#1}}\xspace}

%    \end{macrocode}
%
%



%
%
%    \begin{macrocode}
%%%%% (BEGIN) Macros for Pretty-Print Event-B Components %%%
\newcommand{\SKIP}{\textsc{skip}}


%    \end{macrocode}
%
%
% 


%
%
%
%
%    \begin{macrocode}
%%%%% Pretty print an general Event-B event
%%%%% Arguments:
%%%%% 1. (Optional) convergence status.
%%%%% 2. Name of the event.
%%%%% 3. Name of the abstract event.
%%%%% 4. (Comma-separated) list of parameters.
%%%%% 5. (Newline(\\)-separated) list of guards.
%%%%% 6. (Newline(\\)-separated) list of witness predicates.
%%%%% 7. (Newline(\\)-separated) list of assignments.
%%%%%
%%%%% Usage: \B@event[conv]{conc}{abs}{x,y}{G1(x,y)\\G2(x,y)}{W1\\W2}{S1(v,x,y)\\S2(w,x,y)}
%%%%%       will produce the following
%%%%%
%%%%%       conc
%%%%%       refines abs
%%%%%       status conv
%%%%%       any x, y where
%%%%%         G1(x, y)
%%%%%         G2(x, y)
%%%%%       with
%%%%%         W1
%%%%%         W2
%%%%%       then
%%%%%         S1(v, x, y)
%%%%%         S2(w, x, y)
%%%%%       end
%%%%%
%%%%% Special case:
%%%%% - Empty abstract event --> refines clause is omitted.
%%%%% - Empty convergence status --> status clause is omitted.
%%%%% - Empty witness --> with clause is omitted.
%%%%% - Empty parameters, empty guards --> begin ... end
%%%%% - Empty parameters --> when ... then ... end
%%%%% - Empty actions --> \SKIP
\newcommand{\B@event}[7][]{
  \def\evt@sts{#1}
  \def\evt@name{#2}
  \def\evt@absevts{#3}
  \def\evt@pars{#4}
  \def\evt@grds{#5}
  \def\evt@wits{#6}
  \def\evt@acts{#7}
  %% Pretty-print convergence status
  \ifx\evt@sts\@empty
  \def\pretty@sts{}
  \else
  \def\pretty@sts{\B@tab\Bstatus \B@tab \evt@sts \\}
  \fi
  % Pretty-print abstract events
  \ifx\evt@absevts\@empty
  \def\pretty@absevts{}
  \else
  \def\pretty@absevts{\B@tab\Brefines \B@tab \evt@absevts \\}
  \fi
  % Pretty-print parameters
  \ifx\evt@pars\@empty
  \def\pretty@pars{}
  \else
  \def\pretty@pars{\B@tab\Bany \B@tab \evt@pars \B@tab \Bwhere \\}
  \fi
  % Pretty-print guards
  \ifx\evt@grds\@empty
  \def\pretty@grds{}
  \else
  \def\evt@grds@tmp{
    \begin{array}{@{\B@tab\B@tab}l@{\B@tab}l}
      \evt@grds
    \end{array}\\
  }
  \ifx\evt@pars\@empty
  \def\pretty@grds{
    \B@tab \Bwhen \\
    \evt@grds@tmp
  }
  \else
  \def\pretty@grds{\evt@grds@tmp}
  \fi
  \fi
  % Pretty-print witnesses
  \ifx\evt@wits\@empty
  \def\pretty@wits{}
  \else
  \def\pretty@wits{
    \B@tab\Bwith\\
    \begin{array}{@{\B@tab\B@tab}ll}
      \evt@wits
    \end{array}\\
  }
  \fi
  % Pretty-print actions
  \ifx\evt@acts\@empty
  \def\evt@acts{\SKIP}
  \else
  \fi  
  \def\evt@acts@tmp{
    \begin{array}{@{\B@tab\B@tab}l@{\B@tab}l}
      \evt@acts
    \end{array}\\
  }
  \def\evt@acts@keyword{\B@tab\Bthen \\}
  \ifx\evt@pars\@empty
  \ifx\evt@grds\@empty
  \def\evt@acts@keyword{\B@tab\Bbegin \\}
  \else
  \fi
  \else
  \fi
  \def\pretty@acts{
    \evt@acts@keyword
    \evt@acts@tmp
  }
  % Really do it now
  \begin{array}{l}
    \Bevt{\evt@name} \\
    \pretty@sts
    \pretty@absevts
    \pretty@pars
    \pretty@grds
    \pretty@wits
    \pretty@acts
    \B@tab\Bend
  \end{array}
}

%    \end{macrocode}
%
%
%    \begin{macrocode}
%%%%% Pretty print an general Event-B event
%%%%% Arguments:
%%%%% 1. (Optional) convergence status.
%%%%% 2. Name of the event.
%%%%% 3. Name of the abstract event.
%%%%% 4. (Comma-separated) list of parameters.
%%%%% 5. (Newline(\\)-separated) list of guards.
%%%%% 6. (Newline(\\)-separated) list of witness predicates.
%%%%% 7. (Newline(\\)-separated) list of assignments.
%%%%%
%%%%% Usage: \B@event[conv]{conc}{abs}{x,y}{G1(x,y)\\G2(x,y)}{W1\\W2}{S1(v,x,y)\\S2(w,x,y)}
%%%%%       will produce the following
%%%%%
%%%%%       conc
%%%%%       refines abs
%%%%%       status conv
%%%%%       any x, y where
%%%%%         G1(x, y)
%%%%%         G2(x, y)
%%%%%       with
%%%%%         W1
%%%%%         W2
%%%%%       then
%%%%%         S1(v, x, y)
%%%%%         S2(w, x, y)
%%%%%       end
%%%%%
%%%%% Special case:
%%%%% - Empty abstract event --> refines clause is omitted.
%%%%% - Empty convergence status --> status clause is omitted.
%%%%% - Empty witness --> with clause is omitted.
%%%%% - Empty parameters, empty guards --> begin ... end
%%%%% - Empty parameters --> when ... then ... end
%%%%% - Empty actions --> \SKIP
\newcommand{\B@eventinline}[7][]{
  \def\evt@sts{#1}
  \def\evt@name{#2}
  \def\evt@absevts{#3}
  \def\evt@pars{#4}
  \def\evt@grds{#5}
  \def\evt@wits{#6}
  \def\evt@acts{#7}
  %% Ignore convergence status
  \def\pretty@sts{}
  % Pretty-print abstract events
  \ifx\evt@absevts\@empty
  \def\pretty@absevts{}
  \else
  \def\pretty@absevts{\Brefines~\evt@absevts~}
  \fi
  % Pretty-print parameters
  \ifx\evt@pars\@empty
  \def\pretty@pars{}
  \else
  \def\pretty@pars{\Bany~\evt@pars~\Bwhere~}
  \fi
  % Pretty-print guards
  \ifx\evt@grds\@empty
  \def\pretty@grds{}
  \else
  \def\evt@grds@tmp{
      \evt@grds
  }
  \ifx\evt@pars\@empty
  \def\pretty@grds{
    \Bwhen~
    \evt@grds@tmp~
  }
  \else
  \def\pretty@grds{\evt@grds@tmp~}
  \fi
  \fi
  % Pretty-print witnesses
  \ifx\evt@wits\@empty
  \def\pretty@wits{}
  \else
  \def\pretty@wits{
    \Bwith~
    \evt@wits~
  }
  \fi
  % Pretty-print actions
  \ifx\evt@acts\@empty
  \def\evt@acts{\SKIP}
  \else
  \fi  
  \def\evt@acts@tmp{
    \evt@acts
  }
  \def\evt@acts@keyword{\Bthen}
  \ifx\evt@pars\@empty
  \ifx\evt@grds\@empty
  \def\evt@acts@keyword{\Bbegin}
  \else
  \fi
  \else
  \fi
  \def\pretty@acts{
    \evt@acts@keyword~
    \evt@acts@tmp~
  }
  % Really do it now
  \begin{array}{l}
    \Bevt{\evt@name}~\widehat{=}~
    \pretty@sts
    \pretty@absevts
    \pretty@pars
    \pretty@grds
    \pretty@wits
    \pretty@acts
    \Bend
  \end{array}
}

%    \end{macrocode}
%
%    \begin{macrocode}
%%%%% INITIALISATION label
\newBevt{init}

%%%%% Pretty print the initialisation: no ``refines'' clause. no parameters, no
%%%%% guards
%%%%% Arguments:
%%%%% 1. (Newline(\\)-separated) list of assignments.
%%%%%
%%%%% Usage: \init{S1(v,x,y)\\S2(w,x,y)}
%%%%%       will produce the following
%%%%%
%%%%%       init
%%%%%       begin
%%%%%         S1(v, x, y)
%%%%%         S2(w, x, y)
%%%%%       end
%%%%%
\newcommand{\initialisation}[1]{
  \event{\init}{}{}{}{}{#1}
}
%    \end{macrocode}
%
% \Finale
\endinput